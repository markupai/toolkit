import type { ResponseBase, Status } from "../../utils/api.types";

// Enums
export interface StyleAnalysisSubmitResp {
  workflow_id: string;
  status: Status;
}

export enum StyleOperationType {
  Check = "check",
  Suggestions = "suggestions",
  Rewrite = "rewrite",
}

export enum IssueCategory {
  Grammar = "grammar",
  Clarity = "clarity",
  Tone = "tone",
  Consistency = "consistency",
  Terminology = "terminology",
}

/**
 * Severity level for style issues
 */
export enum IssueSeverity {
  High = "high",
  Medium = "medium",
  Low = "low",
}

/**
 * Base style guide type that a custom style guide extends
 */
export enum BaseStyleGuideType {
  AP = "ap",
  Chicago = "chicago",
  Microsoft = "microsoft",
}

/**
 * Grammar subcategory types
 */
export enum GrammarSubcategory {
  GrammarAgreement = "Grammar Agreement",
  Punctuation = "Punctuation",
  Capitalization = "Capitalization",
  Spelling = "Spelling",
  SentenceStructure = "Sentence Structure",
  VerbForms = "Verb Forms",
  ContextFit = "Context Fit",
  Other = "other",
}

/**
 * Clarity subcategory types
 */
export enum ClaritySubcategory {
  SimplerWords = "Simpler Words",
  ComplexVerbTenses = "Complex Verb Tenses",
  HiddenVerbs = "Hidden Verbs",
  DirectStatements = "Direct Statements",
  PassiveVoice = "Passive Voice",
  PhrasalVerbs = "Phrasal Verbs",
  FormalGrammarForms = "Formal Grammar Forms",
  UnnecessaryWords = "Unnecessary Words",
  SentenceSplitting = "Sentence Splitting",
  ConciseWording = "Concise Wording",
}

/**
 * Tone subcategory types
 */
export enum ToneSubcategory {
  ToneAlignedWording = "Tone-Aligned Wording",
  ToneShapingStructure = "Tone-Shaping Structure",
  ToneSignalPunctuation = "Tone-Signal Punctuation",
  TransitionsAndFlow = "Transitions and Flow",
  AdditionalToneChanges = "Additional Tone Changes",
  Other = "other",
}

/**
 * Consistency subcategory types
 */
export enum ConsistencySubcategory {
  ConsistentPunctuation = "Consistent Punctuation",
  ConsistentCapitalization = "Consistent Capitalization",
  NumbersDatesAndTimes = "Numbers, Dates, and Times",
  InclusiveLanguage = "Inclusive Language",
  SpecialStyleGuideRequirements = "Special Style Guide Requirements",
  Other = "other",
}

/**
 * Terminology subcategory types
 */
export enum TerminologySubcategory {
  Terminology = "Terminology",
  Other = "other",
}

/**
 * Union type for all subcategory types
 */
export type IssueSubcategory =
  | GrammarSubcategory
  | ClaritySubcategory
  | ToneSubcategory
  | ConsistencySubcategory
  | TerminologySubcategory
  | string; // Allow string for backwards compatibility

/**
 * File descriptor interface for style analysis
 */
export interface FileDescriptor {
  file: File;
  mimeType?: string;
}

/**
 * Buffer descriptor interface for style analysis
 */
export interface BufferDescriptor {
  buffer: Buffer;
  mimeType: string;
  documentNameWithExtension: string;
}

/**
 * Base issue type for style analysis
 */
export interface Issue {
  original: string;
  position: {
    start_index: number;
  };
  subcategory: IssueSubcategory;
  category: IssueCategory;
  /**
   * Severity level of the issue
   */
  severity: IssueSeverity;
}

/**
 * Issue with suggestion for style analysis
 */
export interface IssueWithSuggestion extends Issue {
  suggestion: string;
  /**
   * Explanation for the suggestion, generated by the LLM
   */
  explanation?: string;
}

export interface StyleScores {
  quality: {
    score: number;
    grammar: {
      score: number;
      issues: number;
    };
    consistency: {
      score: number;
      issues: number;
    };

    terminology: {
      score: number;
      issues: number;
    };
  };
  analysis: {
    clarity: {
      score: number;
      word_count: number;
      sentence_count: number;
      average_sentence_length: number;
      flesch_reading_ease: number;
      vocabulary_complexity: number;
      sentence_complexity: number;
    };
    tone?: {
      score: number;
      informality: number;
      liveliness: number;
      informality_alignment: number;
      liveliness_alignment: number;
    };
  };
}

export interface StyleAnalysisResponseBase {
  workflow: {
    id: string;
    type: string;
    api_version: string;
    status: Status;
    /**
     * The original name of the file passed into the workflow
     */
    filename?: string;
  };
}

export interface StyleAnalysisSuccessResp extends StyleAnalysisResponseBase {
  workflow: {
    id: string;
    type: string; // e.g., 'checks', 'suggestions', 'rewrites'
    api_version: string;
    generated_at: string;
    status: Status;
    /**
     * The original name of the file passed into the workflow
     */
    filename?: string;
    webhook_response?: {
      url: string;
      status_code: number;
    };
  };
  config: {
    dialect: string;
    style_guide: {
      style_guide_type: string;
      style_guide_id: string;
    };
    tone?: string;
  };
  original: {
    issues: Issue[];
    scores: StyleScores;
  };
}

export interface StyleAnalysisSuggestionResp extends StyleAnalysisSuccessResp {
  original: {
    issues: IssueWithSuggestion[];
    scores: StyleScores;
  };
}

export interface StyleAnalysisRewriteResp extends StyleAnalysisSuggestionResp {
  rewrite: {
    text: string;
    scores: StyleScores;
  };
}

export interface StyleAnalysisErrorResp extends ResponseBase {
  error_message: string;
}

export interface StyleAnalysisReqBase {
  style_guide: string; // Can be style guide ID or name (e.g. 'ap', 'chicago', 'microsoft')
  dialect: string;
  tone?: string;
  webhook_url?: string; // Optional webhook URL for async processing
}

export interface StyleAnalysisReqString extends StyleAnalysisReqBase {
  content: string;
  documentNameWithExtension?: string; // Optional document name for the file upload
}

export interface StyleAnalysisReqFile extends StyleAnalysisReqBase {
  content: FileDescriptor;
}

export interface StyleAnalysisReqBuffer extends StyleAnalysisReqBase {
  content: BufferDescriptor;
}

export type StyleAnalysisReq =
  | StyleAnalysisReqString
  | StyleAnalysisReqFile
  | StyleAnalysisReqBuffer;

export interface StyleGuide {
  id: string;
  name: string;
  created_at: string;
  created_by: string;
  status: string;
  /**
   * The UTC datetime that the style guide was last updated. If null, the style guide has never been updated.
   */
  updated_at?: string;
  /**
   * The ID of the user who last updated the style guide. If null, the style guide has never been updated.
   */
  updated_by?: string;
  /**
   * User-friendly summary of the style guide's contents and characteristics
   */
  summary?: string;
  /**
   * The base style guide type that this style guide extends (AP, Chicago, or Microsoft).
   */
  base_style_guide_type?: BaseStyleGuideType;
  /**
   * List of domain IDs to filter terminology searches by. NULL or empty list means no filtering.
   */
  terminology_domain_ids?: string[];
  /**
   * Whether this style guide has a tone prompt defined.
   */
  has_tone_prompt?: boolean;
}

export type StyleGuides = StyleGuide[];

export interface CreateStyleGuideReq {
  file: File;
  name: string;
}

export interface StyleGuideUpdateReq {
  name: string;
}

// Batch processing types
export interface BatchOptions {
  maxConcurrent?: number;
  retryAttempts?: number;
  retryDelay?: number;
  /**
   * The timeout for the analysis of one content item in milliseconds.
   * @default 5 minutes, 300_000 milliseconds
   */
  timeoutMillis?: number;
}

export interface BatchResult<T = StyleAnalysisResponseType> {
  index: number;
  request: StyleAnalysisReq;
  status: "pending" | "in-progress" | "completed" | "failed";
  result?: T;
  error?: Error;
  workflowId?: string;
  startTime?: number;
  endTime?: number;
}

export interface BatchProgress<T = StyleAnalysisResponseType> {
  total: number;
  completed: number;
  failed: number;
  inProgress: number;
  pending: number;
  results: Array<BatchResult<T>>;
  startTime: number;
  estimatedCompletionTime?: number;
}

export interface BatchResponse<T> {
  progress: BatchProgress<T>;
  promise: Promise<BatchProgress<T>>;
  cancel: () => void;
}

// Type guards for response types
export type StyleAnalysisResponseType =
  | StyleAnalysisSuccessResp
  | StyleAnalysisSuggestionResp
  | StyleAnalysisRewriteResp;

export type BatchResponseType<T> = T extends StyleAnalysisSuccessResp
  ? StyleAnalysisSuccessResp
  : T extends StyleAnalysisSuggestionResp
    ? StyleAnalysisSuggestionResp
    : T extends StyleAnalysisRewriteResp
      ? StyleAnalysisRewriteResp
      : StyleAnalysisResponseType;
